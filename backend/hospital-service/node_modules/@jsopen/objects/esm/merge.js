import { isObject, isPlainObject } from './is-object.js';
import { isBuiltIn } from './type-guards.js';
const hasOwnProperty = Object.prototype.hasOwnProperty;
export function merge(targetObject, sourceObject, options) {
    if (!(isObject(targetObject) || typeof targetObject === 'function')) {
        throw new TypeError('"target" argument must be an object');
    }
    if (sourceObject == null)
        return targetObject;
    if (!(isObject(sourceObject) ||
        typeof sourceObject === 'function' ||
        Array.isArray(sourceObject))) {
        throw new TypeError('"target" argument must be an object or array of objects');
    }
    const keepExisting = options?.keepExisting;
    const keepExistingFn = typeof options?.keepExisting === 'function'
        ? options?.keepExisting
        : undefined;
    const filterFn = options?.filter;
    const ignoreUndefined = options?.ignoreUndefined ?? true;
    const ignoreNulls = options?.ignoreNulls;
    const deep = options?.deep;
    const deepFull = deep === 'full';
    const deepFn = typeof options?.deep === 'function' ? options?.deep : undefined;
    const copyDescriptors = options?.copyDescriptors;
    const mergeArrays = options?.mergeArrays;
    const mergeArraysUnique = options?.mergeArrays === 'unique';
    const mergeArraysFn = typeof options?.mergeArrays === 'function'
        ? options?.mergeArrays
        : undefined;
    const _merge = (target, source, parentPath = '') => {
        if (!isObject(source))
            return;
        const keys = Object.getOwnPropertyNames(source);
        if (options?.symbolKeys ?? true)
            keys.push(...Object.getOwnPropertySymbols(source));
        let key;
        let descriptor;
        let srcVal;
        let _goDeep = false;
        if (isPlainObject(target))
            Object.setPrototypeOf(target, Object.getPrototypeOf(source));
        const ignoreFn = options?.ignoreSource;
        let i = 0;
        const len = keys.length;
        for (i = 0; i < len; i++) {
            key = keys[i];
            /** Should not overwrite __proto__ and constructor properties */
            if (key === '__proto__' || key === 'constructor')
                continue;
            if (copyDescriptors) {
                descriptor = Object.getOwnPropertyDescriptor(source, key);
                if (descriptor?.get || descriptor?.set) {
                    Object.defineProperty(target, key, descriptor);
                    continue;
                }
            }
            srcVal = source[key];
            if (ignoreFn?.(srcVal, {
                key,
                source,
                target,
                path: parentPath + (parentPath ? '.' : '') + String(key),
            })) {
                continue;
            }
            if (keepExisting && hasOwnProperty.call(target, key)) {
                if (!keepExistingFn)
                    continue;
                if (keepExistingFn(srcVal, {
                    key,
                    source,
                    target,
                    path: parentPath + (parentPath ? '.' : '') + String(key),
                })) {
                    continue;
                }
            }
            if (filterFn &&
                !filterFn(srcVal, {
                    key,
                    source,
                    target,
                    path: parentPath + (parentPath ? '.' : '') + String(key),
                })) {
                continue;
            }
            if (ignoreUndefined && srcVal === undefined) {
                continue;
            }
            if (ignoreNulls && srcVal === null) {
                continue;
            }
            if (deep &&
                typeof srcVal === 'object' &&
                (!isBuiltIn(srcVal) || Array.isArray(srcVal))) {
                _goDeep =
                    (deepFn &&
                        deepFn(srcVal, {
                            key,
                            source,
                            target,
                            path: parentPath + (parentPath ? '.' : '') + String(key),
                        })) ||
                        (!deepFn &&
                            (deepFull || isPlainObject(srcVal) || Array.isArray(srcVal)));
                if (_goDeep) {
                    /** Array */
                    if (Array.isArray(srcVal)) {
                        if (Array.isArray(target[key]) &&
                            (mergeArrays ||
                                mergeArraysFn?.(srcVal, {
                                    key,
                                    source,
                                    target,
                                    path: parentPath + (parentPath ? '.' : '') + String(key),
                                }))) {
                            target[key] = _arrayClone(target[key], parentPath + (parentPath ? '.' : '') + String(key));
                        }
                        else
                            target[key] = [];
                        target[key].push(..._arrayClone(srcVal, parentPath + (parentPath ? '.' : '') + String(key)));
                        if (mergeArraysUnique)
                            target[key] = Array.from(new Set(target[key]));
                        continue;
                    }
                    else {
                        /** Object */
                        if (!isObject(target[key]))
                            target[key] = {};
                        _merge(target[key], srcVal, parentPath + (parentPath ? '.' : '') + String(key));
                        continue;
                    }
                }
            }
            if (copyDescriptors) {
                descriptor = { ...Object.getOwnPropertyDescriptor(source, key) };
                descriptor.value = srcVal;
                Object.defineProperty(target, key, descriptor);
                continue;
            }
            target[key] = srcVal;
        }
        return target;
    };
    const _arrayClone = (arr, curPath) => {
        return arr.map((x, index) => {
            if (Array.isArray(x))
                return _arrayClone(x, curPath + '[' + index + ']');
            if (typeof x === 'object' && !isBuiltIn(x))
                return _merge({}, x, curPath + '[' + index + ']');
            return x;
        });
    };
    const sources = Array.isArray(sourceObject) ? sourceObject : [sourceObject];
    for (const src of sources) {
        _merge(targetObject, src);
    }
    return targetObject;
}
