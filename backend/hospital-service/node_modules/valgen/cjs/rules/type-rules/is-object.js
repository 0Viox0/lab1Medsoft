"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isObject = isObject;
const constants_js_1 = require("../../constants.js");
const index_js_1 = require("../../core/index.js");
/**
 * Validates object according to schema
 * Converts properties according to schema rules if coerce option is set to 'true'.
 * @validator isObject
 */
function isObject(schema, options) {
    const ctor = options?.ctor;
    const ctorName = options?.name || ctor?.name;
    const additionalFields = options?.additionalFields ?? !schema;
    const caseInSensitive = !!options?.caseInSensitive;
    const detectCircular = !!options?.detectCircular;
    const propertyRules = {};
    const propertyOptions = {};
    schema = schema || {};
    const schemaKeys = Object.keys(schema);
    for (const k of schemaKeys) {
        const n = schema[k];
        const key = caseInSensitive ? k.toLowerCase() : k;
        if (Array.isArray(n)) {
            if (!(0, index_js_1.isValidator)(n[0])) {
                throw new TypeError(`Invalid tuple definition in validation schema (${k})`);
            }
            propertyRules[key] = n[0];
            propertyOptions[key] = { as: k, ...n[1] };
        }
        else if ((0, index_js_1.isValidator)(n)) {
            propertyRules[key] = n;
            propertyOptions[key] = { as: k };
        }
        else {
            throw new TypeError(`Invalid definition in validation schema (${k})`);
        }
    }
    const _rule = (0, index_js_1.validator)('isObject', (input, context, _this) => {
        let output = input;
        if (ctor && ctor[constants_js_1.preValidation]) {
            output = ctor[constants_js_1.preValidation](output, context, _this);
        }
        const coerce = options?.coerce ?? context.coerce;
        if (typeof output === 'string' && coerce)
            output = JSON.parse(output);
        if (!(output && typeof output === 'object')) {
            context.fail(_this, `Value must be an object`, input);
            return;
        }
        const keys = Array.from(new Set([...Object.keys(output), ...schemaKeys]));
        const l = keys.length;
        let i = 0;
        let inputKey;
        let schemaKey;
        let v;
        let _propRule;
        const out = {};
        if (ctor)
            Object.setPrototypeOf(out, ctor.prototype);
        if (detectCircular) {
            context.circMap = context.circMap || new Map();
            if (context.circMap.has(output)) {
                return context.circMap.get(output);
            }
            context.circMap.set(output, out);
        }
        if (context.root == null)
            context.root = context.root || ctorName || '';
        const location = context.location || '';
        const processedSchemaKeys = {};
        // Iterate object keys and perform rules
        for (i = 0; i < l; i++) {
            inputKey = keys[i];
            schemaKey = caseInSensitive ? inputKey.toLowerCase() : inputKey;
            v = output[inputKey];
            _propRule =
                propertyRules[schemaKey] ||
                    ((0, index_js_1.isValidator)(additionalFields) ? additionalFields : undefined);
            if (_propRule) {
                if (processedSchemaKeys[schemaKey])
                    continue;
                processedSchemaKeys[schemaKey] = true;
                const subCtx = context.extend();
                subCtx.scope = output;
                subCtx.context = ctorName;
                subCtx.location = location + (location ? '.' : '') + schemaKey;
                subCtx.property = schemaKey;
                if (propertyOptions[schemaKey]?.label) {
                    subCtx.label = propertyOptions[schemaKey]?.label;
                }
                v = _propRule(v, subCtx);
            }
            else if (v !== undefined) {
                if (!additionalFields)
                    continue;
                if (additionalFields === 'error') {
                    context.fail(_propRule, `${ctorName || 'Object'} has no field '${inputKey}' and does not accept additional fields`, v);
                }
            }
            if (v !== undefined) {
                out[propertyOptions[schemaKey]?.as || schemaKey] = v;
            }
        }
        if (ctor && ctor[constants_js_1.postValidation]) {
            ctor[constants_js_1.postValidation](out, context, _this);
            return out;
        }
        return out;
    }, options);
    _rule.schema = schema;
    return _rule;
}
