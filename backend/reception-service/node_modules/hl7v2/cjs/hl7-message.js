"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HL7Message = void 0;
const tslib_1 = require("tslib");
const node_process_1 = tslib_1.__importDefault(require("node:process"));
const hl7v2_dictionary_1 = require("hl7v2-dictionary");
const iconv_lite_1 = tslib_1.__importDefault(require("iconv-lite"));
const uid_1 = require("uid");
const constants_js_1 = require("./constants.js");
const hl7_error_js_1 = require("./hl7-error.js");
const hl7_message_node_js_1 = require("./hl7-message-node.js");
const hl7_segment_js_1 = require("./hl7-segment.js");
class HL7Message {
    constructor(version = hl7v2_dictionary_1.HL7Version.v2_7_1, dictionaries) {
        this.fieldSeparator = constants_js_1.FIELD_SEPARATOR;
        this.componentSeparator = constants_js_1.COMPONENT_SEPARATOR;
        this.subComponentSeparator = constants_js_1.SUBCOMPONENT_SEPARATOR;
        this.repetitionSeparator = constants_js_1.REPETITION_SEPARATOR;
        this.escapeCharacter = constants_js_1.ESCAPE_CHARACTER;
        this._dictionaries = dictionaries || hl7v2_dictionary_1.dictionaries;
        this._version = version;
        this.clear(version);
    }
    get dictionary() {
        return this._dictionary;
    }
    get segments() {
        return this._segments;
    }
    get header() {
        return this.getSegment('MSH');
    }
    get version() {
        return this._version;
    }
    get messageType() {
        const f = this.header.field(hl7v2_dictionary_1.MSHSegment.MessageType);
        if (!f)
            return '';
        return f.getValue(1) + '^' + f.getValue(2);
    }
    get controlId() {
        return this.header.field(hl7v2_dictionary_1.MSHSegment.MessageControlID).toHL7String();
    }
    clear(version) {
        this._clear(version);
        const msh = this.addSegment('MSH');
        msh.field(hl7v2_dictionary_1.MSHSegment.DateTimeOfMessage).setValue(new Date());
        msh.field(hl7v2_dictionary_1.MSHSegment.MessageControlID).setValue((0, uid_1.uid)(8));
        msh.field(hl7v2_dictionary_1.MSHSegment.VersionID).setValue(version);
        msh.field(hl7v2_dictionary_1.MSHSegment.CharacterSet).setValue('UTF-8');
    }
    addSegment(segmentType, index) {
        const segment = new hl7_segment_js_1.HL7Segment(this, segmentType);
        if (index !== undefined && index < this.segments.length) {
            this.segments.splice(index, 0, segment);
        }
        else {
            this.segments.push(segment);
        }
        return segment;
    }
    /**
     * Searches for a segment of a given type
     */
    getSegment(segmentType, indexOrAfter) {
        let k = 0;
        for (let i = 0; i < this.segments.length; i++) {
            const seg = this.segments[i];
            if (seg instanceof hl7_segment_js_1.HL7Segment && seg.segmentType === segmentType) {
                if (!indexOrAfter)
                    return seg;
                if (typeof indexOrAfter === 'number') {
                    if (indexOrAfter === k++)
                        return seg;
                }
                else {
                    if (indexOrAfter === seg)
                        indexOrAfter = undefined;
                }
            }
        }
    }
    /**
     * Searches for a segment of a given type in reverse order
     */
    getSegmentFromLast(segmentType, indexOrAfter) {
        let k = 0;
        for (let i = this.segments.length - 1; i >= 0; i--) {
            const seg = this.segments[i];
            if (seg instanceof hl7_segment_js_1.HL7Segment && seg.segmentType === segmentType) {
                if (!indexOrAfter)
                    return seg;
                if (typeof indexOrAfter === 'number') {
                    if (indexOrAfter === k++)
                        return seg;
                    i++;
                }
                else {
                    if (indexOrAfter === seg)
                        indexOrAfter = undefined;
                }
            }
        }
    }
    toHL7String(options) {
        return (this.segments
            .map(segment => segment.toHL7String(options))
            .filter(v => v)
            .join(constants_js_1.CR) + constants_js_1.CR);
    }
    parse(input, options) {
        const raw = HL7Message.parseRaw(input);
        this._clear(raw.version);
        this.fieldSeparator = raw.fieldSeparator;
        this.componentSeparator = raw.componentSeparator;
        this.repetitionSeparator = raw.repetitionSeparator;
        this.escapeCharacter = raw.escapeCharacter;
        this.subComponentSeparator = raw.subComponentSeparator;
        const lines = raw.data.replaceAll(constants_js_1.CR + constants_js_1.LF, constants_js_1.CR).split(constants_js_1.CR);
        const headerItems = raw.header.split(this.fieldSeparator);
        for (const [i, line] of lines.entries()) {
            if (!line)
                continue;
            try {
                const segment = hl7_segment_js_1.HL7Segment.parse(this, line, options);
                this._segments.push(segment);
            }
            catch (e) {
                if (!this.header) {
                    this.addSegment('MSH');
                }
                this.header
                    .field(hl7v2_dictionary_1.MSHSegment.SendingApplication)
                    .setValue(headerItems[2]);
                this.header.field(hl7v2_dictionary_1.MSHSegment.SendingFacility).setValue(headerItems[3]);
                this.header
                    .field(hl7v2_dictionary_1.MSHSegment.ReceivingApplication)
                    .setValue(headerItems[4]);
                this.header
                    .field(hl7v2_dictionary_1.MSHSegment.ReceivingFacility)
                    .setValue(headerItems[5]);
                this.header.field(hl7v2_dictionary_1.MSHSegment.EncodingCharacters).setValue(raw.encoding);
                this.header.field(hl7v2_dictionary_1.MSHSegment.MessageControlID).setValue(headerItems[9]);
                this.header.field(hl7v2_dictionary_1.MSHSegment.VersionID).setValue(raw.version);
                /* c8 ignore next */
                const e1 = e instanceof hl7_error_js_1.HL7Error ? e : new hl7_error_js_1.HL7Error(e.message);
                e1.stack = e.stack;
                if (e1.segmentType) {
                    const lastSeg = this.getSegmentFromLast(e.segmentType);
                    if (lastSeg)
                        e1.segmentSequence = lastSeg.index;
                }
                e1.line = i + 1;
                throw e1;
            }
        }
    }
    buildStructureTree() {
        // Get the message type to determine the structure
        const messageType = this.messageType.replace('^', '_');
        const messageDefinition = this.dictionary.messages?.[messageType];
        if (!messageDefinition?.segments) {
            const result = new hl7_message_node_js_1.HL7MessageNode('MESSAGE');
            result.items.push(...this.segments);
        }
        // Helper function to process a segment definition recursively
        const processSegmentDefinition = (segmentDef, nodeName, currentSegmentIndex) => {
            const node = new hl7_message_node_js_1.HL7MessageNode(nodeName);
            // Sort segment definitions by their index
            const sortedEntries = Object.entries(segmentDef).sort(([, a], [, b]) => (a.idx || 0) - (b.idx || 0));
            for (const [key, def] of sortedEntries) {
                if (def.segments) {
                    // This is a group - process recursively
                    const maxOccurrences = def.max || Number.MAX_SAFE_INTEGER;
                    let occurrenceCount = 0;
                    const initialSegmentIndex = currentSegmentIndex.value;
                    // Try to match segments for this group
                    while (occurrenceCount < maxOccurrences &&
                        currentSegmentIndex.value < this.segments.length) {
                        const groupStartIndex = currentSegmentIndex.value;
                        const groupNode = processSegmentDefinition(def.segments, key, currentSegmentIndex);
                        // Check if we actually consumed any segments
                        if (currentSegmentIndex.value > groupStartIndex &&
                            groupNode.items.length > 0) {
                            node.items.push(groupNode);
                            occurrenceCount++;
                        }
                        else {
                            // No segments matched, break the loop
                            break;
                        }
                    }
                    // If no occurrences found, reset to initial position
                    if (occurrenceCount === 0) {
                        currentSegmentIndex.value = initialSegmentIndex;
                    }
                }
                else {
                    // This is a leaf segment
                    const maxOccurrences = def.max || Number.MAX_SAFE_INTEGER;
                    const segmentType = key;
                    // Match segments of this type
                    let matchedCount = 0;
                    while (matchedCount < maxOccurrences &&
                        currentSegmentIndex.value < this.segments.length) {
                        const currentSegment = this.segments[currentSegmentIndex.value];
                        if (currentSegment.segmentType === segmentType) {
                            node.items.push(currentSegment);
                            currentSegmentIndex.value++;
                            matchedCount++;
                        }
                        else {
                            // Different segment type - stop matching
                            break;
                        }
                    }
                }
            }
            return node;
        };
        const segmentIndexRef = { value: 0 };
        const result = processSegmentDefinition(messageDefinition.segments, messageType, segmentIndexRef);
        // Add any remaining unmatched segments to the result
        while (segmentIndexRef.value < this.segments.length) {
            const segment = this.segments[segmentIndexRef.value];
            result.items.push(segment);
            segmentIndexRef.value++;
        }
        return result;
    }
    createAck(ackCode = 'AA', textMessage) {
        const out = new HL7Message(this.version, this._dictionaries);
        const msh = out.header;
        // Sending Application
        msh
            .field(hl7v2_dictionary_1.MSHSegment.ReceivingApplication)
            .setValue(msh.field(hl7v2_dictionary_1.MSHSegment.SendingFacility).getValue());
        msh
            .field(hl7v2_dictionary_1.MSHSegment.ReceivingFacility)
            .setValue(this.header.field(hl7v2_dictionary_1.MSHSegment.SendingFacility).getValue());
        msh.field(hl7v2_dictionary_1.MSHSegment.MessageType).setValue('ACK');
        msh
            .field(hl7v2_dictionary_1.MSHSegment.MessageType)
            .comp(2)
            .setValue(this.header.field(hl7v2_dictionary_1.MSHSegment.MessageType).getValue(2));
        msh
            .field(hl7v2_dictionary_1.MSHSegment.MessageControlID)
            .setValue(String(Date.now() + (0, uid_1.uid)(5)));
        const msa = out.addSegment('MSA');
        msa.field(hl7v2_dictionary_1.MSASegment.AcknowledgmentCode).setValue(ackCode);
        msa
            .field(hl7v2_dictionary_1.MSASegment.MessageControlID)
            .setValue(this.header.field(hl7v2_dictionary_1.MSHSegment.MessageControlID).getValue());
        if (textMessage)
            msa.field(hl7v2_dictionary_1.MSASegment.TextMessage).setValue(textMessage);
        return out;
    }
    createNak(errors) {
        const out = new HL7Message(this.version, this._dictionaries);
        const msh = out.header;
        // Sending Application
        msh
            .field(hl7v2_dictionary_1.MSHSegment.ReceivingApplication)
            .setValue(msh.field(hl7v2_dictionary_1.MSHSegment.SendingFacility).getValue());
        msh
            .field(hl7v2_dictionary_1.MSHSegment.ReceivingFacility)
            .setValue(this.header.field(hl7v2_dictionary_1.MSHSegment.SendingFacility).getValue());
        msh.field(hl7v2_dictionary_1.MSHSegment.MessageType).setValue('ACK');
        msh
            .field(hl7v2_dictionary_1.MSHSegment.MessageType)
            .comp(2)
            .setValue(this.header.field(hl7v2_dictionary_1.MSHSegment.MessageType).getValue(2));
        msh
            .field(hl7v2_dictionary_1.MSHSegment.MessageControlID)
            .setValue(String(Date.now() + (0, uid_1.uid)(5)));
        const msaSegment = out.addSegment('MSA');
        msaSegment.field(hl7v2_dictionary_1.MSASegment.AcknowledgmentCode).setValue('AE');
        msaSegment
            .field(hl7v2_dictionary_1.MSASegment.MessageControlID)
            .setValue(this.header.field(hl7v2_dictionary_1.MSHSegment.MessageControlID).getValue());
        for (const error of errors) {
            out.addError(error);
        }
        return out;
    }
    addError(error) {
        let msaSegment = this.getSegment('MSA');
        if (!msaSegment)
            msaSegment = this.addSegment('MSA');
        if (error instanceof Error) {
            msaSegment.field(hl7v2_dictionary_1.MSASegment.TextMessage).setValue(error.message);
        }
        else
            msaSegment.field(hl7v2_dictionary_1.MSASegment.TextMessage).setValue(String(error));
        const errSegment = this.addSegment('ERR');
        if (error instanceof hl7_error_js_1.HL7Error) {
            errSegment
                .field(hl7v2_dictionary_1.ERRSegment.HL7ErrorCode)
                .setValue(error.hl7ErrorCode || 207);
            errSegment.field(hl7v2_dictionary_1.ERRSegment.Severity).setValue(error.severity);
            errSegment
                .field(hl7v2_dictionary_1.ERRSegment.ApplicationErrorCode)
                .setValue(error.appErrorCode);
            const errLocation = errSegment.field(hl7v2_dictionary_1.ERRSegment.ErrorLocation);
            errLocation.comp(hl7v2_dictionary_1.ERLType.SegmentID).setValue(error.segmentType);
            errLocation.comp(hl7v2_dictionary_1.ERLType.SegmentSequence).setValue(error.segmentSequence);
            errLocation.comp(hl7v2_dictionary_1.ERLType.FieldPosition).setValue(error.fieldPosition);
            errLocation
                .comp(hl7v2_dictionary_1.ERLType.ComponentNumber)
                .setValue(error.componentPosition);
            errLocation.comp(hl7v2_dictionary_1.ERLType.FieldRepetition).setValue(error.repetitionIndex);
            errLocation
                .comp(hl7v2_dictionary_1.ERLType.SubComponentNumber)
                .setValue(error.subComponentPosition);
            if ((node_process_1.default?.env.NODE_ENV || '').startsWith('dev')) {
                errSegment
                    .field(hl7v2_dictionary_1.ERRSegment.DiagnosticInformation)
                    .setValue(error.stack);
            }
        }
        else {
            errSegment.field(hl7v2_dictionary_1.ERRSegment.HL7ErrorCode).setValue(207);
            errSegment.field(hl7v2_dictionary_1.ERRSegment.Severity).setValue('E');
            if (error instanceof Error) {
                if (error.code)
                    errSegment
                        .field(hl7v2_dictionary_1.ERRSegment.ApplicationErrorCode)
                        .setValue(error.code);
            }
        }
    }
    _clear(version) {
        if (!version)
            version = this._version || hl7v2_dictionary_1.HL7Version.v2_7_1;
        this._version = version;
        const nearestVersion = (0, hl7v2_dictionary_1.findNearestHL7Version)(version);
        this._dictionary = this._dictionaries[nearestVersion];
        this._segments = [];
        this.fieldSeparator = constants_js_1.FIELD_SEPARATOR;
        this.componentSeparator = constants_js_1.COMPONENT_SEPARATOR;
        this.subComponentSeparator = constants_js_1.SUBCOMPONENT_SEPARATOR;
        this.repetitionSeparator = constants_js_1.REPETITION_SEPARATOR;
        this.escapeCharacter = constants_js_1.ESCAPE_CHARACTER;
    }
    /**
     *
     * @static
     */
    static parse(input, options) {
        const message = new HL7Message(undefined, options?.dictionaries);
        message.parse(input, options);
        return message;
    }
    /**
     *
     * @static
     */
    static parseRaw(input) {
        let headerStr = '';
        if (Buffer.isBuffer(input)) {
            let crIdx = input.indexOf(constants_js_1.CR);
            if (crIdx < 0)
                crIdx = input.length;
            headerStr = input.toString('utf8', 0, crIdx);
        }
        else if (typeof input === 'string') {
            let crIdx = input.indexOf(constants_js_1.CR);
            if (crIdx < 0)
                crIdx = input.length;
            headerStr = input.substring(0, crIdx);
        } /* c8 ignore else */
        else {
            throw new TypeError('You must provide string or Buffer argument');
        }
        if (headerStr.startsWith(constants_js_1.VT))
            headerStr = headerStr.substring(1);
        if (!headerStr.startsWith('MSH'))
            throw new hl7_error_js_1.HL7Error('Message must start with (MSH) segment', {
                line: 1,
                hl7ErrorCode: 100,
            });
        const fieldSeparator = headerStr[3];
        /* Detect version and charset */
        const headerItems = headerStr.split(fieldSeparator);
        const version = headerItems[11];
        const charset = headerItems[17]?.split('^')[0];
        let encoding = HL7Message.encodingMapping[charset] || charset || 'utf-8';
        try {
            iconv_lite_1.default.getDecoder(charset);
        }
        catch {
            encoding = 'utf-8';
        }
        let str = Buffer.isBuffer(input) ? iconv_lite_1.default.decode(input, encoding) : input;
        if (str.startsWith(constants_js_1.VT))
            str = str.substring(1);
        const k = str.indexOf(constants_js_1.FS);
        if (k >= 0)
            str = str.substring(0, k);
        return {
            fieldSeparator,
            componentSeparator: headerItems[1][0],
            repetitionSeparator: headerItems[1][1],
            escapeCharacter: headerItems[1][2],
            subComponentSeparator: headerItems[1][3],
            messageType: headerItems[8],
            header: headerStr,
            data: str,
            encoding,
            version: version,
        };
    }
}
exports.HL7Message = HL7Message;
HL7Message.encodingMapping = {
    ASCII: 'ascii',
    '8859/1': 'latin1',
    '8859/2': 'latin2',
    '8859/3': 'ISO-8859-3',
    '8859/4': 'ISO-8859-4',
    '8859/5': 'ISO-8859-5',
    '8859/6': 'ISO-8859-6',
    '8859/7': 'ISO-8859-7',
    '8859/8': 'ISO-8859-8',
    '8859/9': 'latin5',
    '8859/15': 'latin9',
    'ISO IR6': 'ascii',
    'ISO IR14': 'ISO-2022-JP',
    'ISO IR87': 'ISO-2022-JP',
    'ISO IR159': 'ISO-2022-JP-2',
    'GB 18030-2000': 'gb18030',
    'KS X 1001': 'EUC-KR',
    'CNS 11643-1992': 'EUC-TW',
    'BIG-5': 'Big5',
    UNICODE: 'utf16-le',
    'UNICODE UTF-8': 'utf8',
    'UNICODE UTF-16': 'utf16-le',
    // ⚠️ UTF-32 iconv-lite tarafından desteklenmez
};
