"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HL7Segment = void 0;
const hl7_field_js_1 = require("./hl7-field.js");
class HL7Segment {
    constructor(message, segmentType) {
        this.segmentType = '';
        this.message = message;
        this.segmentType = segmentType;
        this._definition = this.message.dictionary.segments[this.segmentType] || {
            fields: {},
        };
        this.clear();
    }
    get definition() {
        return this._definition;
    }
    get fields() {
        return this._fields;
    }
    get index() {
        return this.message.segments.indexOf(this);
    }
    clear() {
        this._fields = [];
    }
    field(fieldPos) {
        if (fieldPos < 1)
            throw new Error('Invalid field position');
        let field = this._fields[fieldPos - 1];
        if (!field) {
            const fDef = this.definition.fields[String(fieldPos)] || {
                type: 'ST',
            };
            field = new hl7_field_js_1.HL7Field(this, fieldPos, fDef || { type: 'ST' });
            this._fields[fieldPos - 1] = field;
        }
        return field;
    }
    defineField(position, def) {
        if (position < 1)
            throw new Error(`Invalid field position (${position})`);
        def.type = def.type || 'ST';
        return (this._fields[position - 1] = new hl7_field_js_1.HL7Field(this, position, def));
    }
    toHL7String(options) {
        const { fieldSeparator } = this.message;
        let out = this.segmentType + fieldSeparator;
        if (this.segmentType === 'MSH') {
            out +=
                this.message.componentSeparator +
                    this.message.repetitionSeparator +
                    this.message.escapeCharacter +
                    this.message.subComponentSeparator +
                    fieldSeparator;
        }
        const serializeFields = this._fields.map(field => field.toHL7String(options));
        if (this.segmentType === 'MSH') {
            serializeFields.shift();
            serializeFields.shift();
        }
        out += serializeFields.join(fieldSeparator);
        while (out.endsWith(fieldSeparator))
            out = out.substring(0, out.length - 1);
        return out;
    }
    static parse(message, input, options) {
        const fields = input.split(message.fieldSeparator);
        const segment = new HL7Segment(message, fields[0]);
        if (segment.segmentType === 'MSH')
            fields[0] = message.fieldSeparator;
        else
            fields.shift();
        for (let i = 0; i < fields.length; i++) {
            segment.field(i + 1).fromHL7String(fields[i], options);
        }
        return segment;
    }
}
exports.HL7Segment = HL7Segment;
